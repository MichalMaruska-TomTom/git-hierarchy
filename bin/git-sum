#! /usr/bin/zsh -feu

# Manage the Sum information:
# list ..
# add
# remove
#

usage()
{
    cat <<EOF
Usage:
${0##*/} [+-h]
  list all Sums
${0##*/} [-c] branch
  show the Sum definition, possibly pruning non-existings summands

${0##*/} [-r] branch new-merge-branch -drop-merge-branch ...
  modify the definition.  -r Resets/empties

${0##*/} [-d] branch
  drop the definition.
EOF
}

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)
SUM_DIR=$GIT_DIR/mmc


# print valid/existing components of the sum
show_prune_definition()
{
    if [ $# = 2 ];then
	silent="y"
    else
	silent="n"
    fi

    cat $1 | \
    while read a;do
	if git-branch-exists $a; then
	    echo $a
	else
	    if [ $silent != "y" ]; then
		echo NON-existant $a
	    fi
	fi
    done
}


if [ $# = 0 ];
then
    # avoid bug! (dependency on NULL_GLOB.)
    { list_sums } always { TRY_BLOCK_ERROR=0 }
    exit 0;
fi



usage()
{
    cat <<EOF
Usage:
${0##*/} [+-h]
${0##*/} branch
${0##*/} -d branch
${0##*/} -c branch     prune ...
  -c correct: check that summands exist, forget about them if not.

${0##*/} [-r] branch new-merge-branch -drop-merge-branch ...
  -r reset: empty the definition first.
EOF
}

reset="n"
correct="n"
delete=n

while getopts :hrcd OPT; do
    case $OPT in
	h|+h)
	    usage
	    exit 0
	    ;;
	r)
	    reset="y"
	    ;;
	c)
	    correct="y"
	    ;;
	d)
	    delete="y"
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift $(( OPTIND - 1 ))
OPTIND=1



if [ $# -lt 1 ]; then
    usage
    exit -1
fi

name=$1
shift

if [ $delete = y ]; then
    rm -v $SUM_DIR/$name
    git branch -d $name
    exit 0
fi


# create the branch:
[ -e $GIT_DIR/refs/heads/$name ] || git branch $name


# ensure-dir
[ -d $SUM_DIR ] || mkdir $SUM_DIR
sum_file=$SUM_DIR/$name

if [ $reset = "y" ];then
    rm $sum_file
fi

if [ $# = 0 ]; then
    if [ $correct = y ]; then
	TEMP=$(mktemp)
	show_prune_definition $sum_file "silent" > $TEMP
	# >!
	sort -u $TEMP > $sum_file
    else
	show_prune_definition $sum_file
    fi
else
    for br in "$@"
    do
	case "$br" in
	    -*)
		br=$(expr substr "$br" 2 $(expr length "$br" ) )
		cecho red $br
		temp=${TEMP-/tmp}/git-define-sum
		grep -v -e "^$br$" $sum_file > $temp
		mv $temp $sum_file
		;;
	    +*)
		cecho green ${br#+}
		echo ${br#+} >> $sum_file
		;;
	    *)
		cecho green $br
		echo $br >> $sum_file
		;;
	esac
    done
    cat $sum_file
fi
