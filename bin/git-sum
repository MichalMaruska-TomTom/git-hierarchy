#! /usr/bin/zsh -feu

# Manage the Sum information:
# list ..
# add
# remove
#

usage()
{
    cat <<EOF
Usage:
${0##*/} [+-h]
  list all Sums
${0##*/} [-c] branch
  show the Sum definition, possibly pruning non-existings summands

${0##*/} [-r] branch new-merge-branch -drop-merge-branch ...
  modify the definition.  -r Resets/empties

${0##*/} [-d] branch
  drop the definition.
EOF
}



source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)


delete_sum_definition()
{
    # delete all of them:
    local name=$1
    git for-each-ref "refs/sums/$name/" --format "%(refname)" |\
    (while read ref;
	do
	drop_symbolic_ref $ref
	done
    )
}

find_new_index(){
    local name=$1
    typeset -i i=1
    git for-each-ref "refs/sums/$name/" --format "%(refname)" |\
    while read ref; do
	if [ ${ref##*/} -ge $i ]; then
	    ((i=${ref##*/}+1))
	fi
    done
    echo $i
}

remove_from_sum(){
    local sum=$1
    local summand=$2
    git for-each-ref "refs/sums/$name/" --format "%(refname)" |\
    ( while read ref;
	do
	if dump_ref $ref |grep -F "ref: $summand";
	then
	    #remove it:
	    drop_symbolic_ref $ref
	fi
	done)
}

add_to_sum()
{
    local sum=$1
    local addend=$2
    local index=$3

    set -x
    cecho yellow "adding to sum $sum: $addend, as $index"
    local ref=refs/sums/$sum/$index

    set_symbolic_reference $ref  "ref: $addend"
    # git symbolic-ref $ref  "ref: $addend"
    # $(git show-ref $addend | head -n 1| cut -f 2 -d ' ')
    #echo $br >> $sum_file
}



# print valid/existing components of the sum
show_prune_definition()
{
    local silent
    if [ $# = 2 ];then
	silent="y"
    else
	silent="n"
    fi
    local a

    git for-each-ref "refs/sums/$name/" --format "%(refname)" | \
    while read a;do
	# git-branch-exists
	local ref="$(git symbolic-ref $a)"
	local hash="$(git show-ref $a)"
	if [ -n "$hash" ]; then
	   echo "$ref"
	else
	    if [ $silent != "y" ]; then
		echo NON-existant $ref = $a
	    fi
	fi
    done
}


if [ $# = 0 ];
then
    # avoid bug! (dependency on NULL_GLOB.)
    { list_sums } always { TRY_BLOCK_ERROR=0 }
    exit 0;
fi



usage()
{
    cat <<EOF
Usage:
${0##*/} [+-h]
${0##*/} branch
${0##*/} -d branch
${0##*/} -c branch     prune ...
  -c correct: check that summands exist, forget about them if not.

${0##*/} [-r] branch new-merge-branch -drop-merge-branch ...
  -r reset: empty the definition first.
EOF
}

reset="n"
correct="n"
delete=n

while getopts :hrcd OPT; do
    case $OPT in
	h|+h)
	    usage
	    exit 0
	    ;;
	r)
	    reset="y"
	    ;;
	c)
	    correct="y"
	    ;;
	d)
	    delete="y"
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift $(( OPTIND - 1 ))
OPTIND=1



if [ $# -lt 1 ]; then
    usage
    exit -1
fi

name=$1
shift



if [ $delete = y ]; then
    delete_sum_definition $name
    git branch -d $name
    exit 0
fi




if [ $reset = "y" ];then
    delete_sum_definition $name
fi


if [ $# = 0 ]; then
    if [ $correct = y ]; then
	TEMP=$(mktemp)
	show_prune_definition $name "silent" > $TEMP
	# todo!
	# delete those that don't exist.
    else
	show_prune_definition $name
    fi
else

    # create the branch:
    [ -e $GIT_DIR/refs/heads/$name ] || git branch $name

    # now creation:
    # find minimal number:
    index=$(find_new_index $name)
    for br in "$@"
    do
	case "$br" in
	    -*)
		br=${br#-}
		# I need to `expand' to `Full' ref!
		br=$(git-expand-ref $br)

		# remove:
		# find its index!
		cecho red $br
		remove_from_sum $name $br
		;;
	    +*)
		br=${br#+}
		cecho green "addend $br"
		# add:
		br=$(git-expand-ref $br)
		add_to_sum $name $br $index
		((index=index+1))
		;;
	    *)
		cecho green $br
		;;
	esac
    done
fi
