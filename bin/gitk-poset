#!/bin/zsh -eu

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

usage()
{
setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [+-f|g] [-v] [--] REF...

REF is segment or sum
-f  show the whole poset! (uses git-tsort to get the base).
-g  the whole graphs (segments, sums)

-v  verbose

# to be used:
# $0 mmc-segment
# will invoke gitk(1) on .... mmc-segment..base/mmc-segment?
# or even mmc-sum including all summands

EOF
unsetopt POSIX_ARGZERO
}

MAX=2000

full_poset=n
all_graph=n
verbose=n
while getopts :fgv OPT; do
    case $OPT in
        f|+f)
            full_poset=y
            ;;
        g)
            all_graph=y
            ;;
        v)
            verbose=y
            ;;
        *)
            usage >&2
            exit 2
    esac
done

shift $(( OPTIND - 1 ))
OPTIND=1


if [ $all_graph = y ]; then

    GRAPH=$(tempfile)
    dump_whole_graph > $GRAPH

    # Covered are those who are ancestors of others!
    # but it's not A base B. it must be verified that B is indeed below it! If B has moved, I want to see it!
    VERTICES=$(tempfile)
    ANCESTORS=$(tempfile)
    cat $GRAPH | cut --fields=1 |sort -u > $VERTICES
    cat $GRAPH | cut -d '	' --fields 2- | sed -e "s/ /\n/g"| sort -u > $ANCESTORS
    # 3 common, 2 unique to ancestors = base.
    roots=( $(comm -1 -3 $VERTICES $ANCESTORS) ) #unique to ancestors.
    tops=( $(comm -2 -3 $VERTICES $ANCESTORS) ) #unique to ancestors.
    for ((i=1; i<= ${#roots}; i++))
        {echo $i $roots[$i]; roots[$i]="$roots[$i]^!"; echo $roots[$i] }
    gitk --max-count=$MAX  $roots $tops HEAD
    echo rm -f $VERTICES $ANCESTORS $GRAPH
    exit 0
fi


#### local version:

# only 1?
if [ $# -gt 1 ]; then
    usage >&2
    exit 1
elif [ $# = 0 ]; then
    # default:
    ref_name=$(git rev-parse --symbolic-full-name "HEAD")
else
    ref_name=$1
fi
ref_name=${ref_name#refs/heads/}



if [[ $full_poset = n ]] && is_segment $ref_name; then
    bottom=refs/start/$ref_name
else
    bottom=$(git-walk-down $ref_name |head -n 1)
fi

if is_sum $ref_name;
then
    typeset -a summands
    summands=($(git-sum $ref_name))

    typeset -a ranges
    ranges=($bottom..heads/$ref_name)

    set -x
    gitk $ranges
else
    set -x
    gitk ${bottom#refs/}...heads/$ref_name
fi
# full_poset:
# git-walk-down mmc-focus |
