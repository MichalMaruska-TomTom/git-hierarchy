#!/bin/zsh -eu

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)
GITK=gitk

usage()
{
setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [+-f|l] [-v] [--]    [REF]

REF is segment or sum. By default HEAD is used.
-f  show the whole poset! (uses git-tsort to get the base).
-l  only the current segment/sum

-v  verbose

# to be used:
# $0 mmc-segment
# will invoke gitk(1) on .... mmc-segment..base/mmc-segment?
# or even mmc-sum including all summands

EOF
unsetopt POSIX_ARGZERO
}

MAX=2000

full_poset=n  # take it full-depth, not just 1 segment/sum
all_graph=y # take all tops, not just current branch
verbose=n
while getopts :flv OPT; do
    case $OPT in
        f|+f)
            full_poset=y
            ;;
        l)
            all_graph=n
            ;;
        v)
            verbose=y
            ;;
        *)
            usage >&2
            exit 2
    esac
done

shift $(( OPTIND - 1 ))
OPTIND=1


if [ $all_graph = y ]; then
    find_roots_and_tops

    # echo now prefix:
    for ((i=1; i<= ${#roots}; i++))
        {echo $i $roots[$i]; roots[$i]="$roots[$i]^!"; echo $roots[$i] }
    # echo now
    # "${roots[*]^@}"
    # convert:
    #    echo ${#roots}
    #    set -x
    $GITK --title="poset" --max-count=$MAX $roots $tops HEAD
    exit 0
fi


#### local version:

# only 1?
if [ $# -gt 1 ]; then
    usage >&2
    exit 1
elif [ $# = 0 ]; then
    # default:
    ref_name=$(git rev-parse --symbolic-full-name "HEAD")
else
    ref_name=$1
fi
ref_name=${ref_name#refs/heads/}



if [[ $full_poset = n ]] && is_segment $ref_name; then
    bottom=refs/start/$ref_name
else
    bottom=$(git-walk-down $ref_name |head -n 1)
fi

if is_sum $ref_name;
then
    typeset -a summands
    summands=($(git-sum $ref_name))

    typeset -a ranges
    ranges=($bottom..heads/$ref_name)

    set -x
    $GITK --title="sum $ref_name" $ranges
else
    set -x
    $GITK --title="segment $ref_name" ${bottom#refs/}...heads/$ref_name
fi
# full_poset:
# git-walk-down mmc-focus |
