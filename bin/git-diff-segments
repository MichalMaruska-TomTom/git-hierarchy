#!/bin/zsh -feu

# Given 2 dumps of segments, produced by ../bin/git-dump-refs
# compare the content of same-name-segment.

# Outputs:
# runs diff(1) by field patch-id ... and shows the related commit-id message.

name=$1
dump=$2
dump2=$3

GAWK_FILE="/usr/share/git-hierarchy/dump-segment"

temp=$(mktemp)
temp2=$(mktemp)

show_commit()
{
    #  commit dir
    cd $2
    git show --oneline -s $1
}
usage()
{
    cat <<EOF
print "usage: ${0##*/} [+-v] [--] ARGS..."

-v verbose
EOF
}

verbose=n
while getopts :hv OPT; do
    case $OPT in
        h)
            usage;exit 0
            ;;
        v|+v)
            verbose=y
            ;;
        *)
            usage >&2
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1

gawk -v requested="refs/heads/$name" -f $GAWK_FILE < $dump | cut -f 1 -d ' ' > $temp
gawk -v requested="refs/heads/$name" -f $GAWK_FILE < $dump2 | cut -f 1 -d ' ' > $temp2

find_commit_of_patchid()
{
    readonly commit=$1
    readonly dump_file=$2

(if [ $verbose = y ]; then set -x;fi; diff $temp $temp2) |
    grep $commit $dump_file| cut -f 2 -d ' '
}

    while read line; do
        if [[ $line[1] = "<"  ]]
        then
            commit=$(find_commit_of_patchid ${line#< })
            show_commit $commit $(dirname $dump)
        elif [[ $line[1] = ">"  ]]
        then
            commit=$(find_commit_of_patchid ${line#> })
            show_commit $commit $(dirname $dump2)
        else
            # 0a1,2
            echo "ignoring $line" >&2
        fi
    done

rm -f $temp $temp2
