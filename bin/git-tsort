#! /usr/bin/zsh -feu

# Generate list of my known branches (sums & segments)
# and output them in topological order.

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

keep_graph="n"
just_graph=n

while getopts :kg OPT; do
    case $OPT in
	k|+k)
	    keep_graph=y
	    ;;
	g)
	    just_graph=y
	    ;;
	*)
	    print "usage: ${0##*/} [+-k} [--] ARGS..."
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1

# Get a temp file:
# generate
GRAPH=$(mktemp --tmpdir=${TEMP-/run/tmp/}  graph.XXX)


# segments ... look at bases.
setopt NULL_GLOB

typeset -a segments
# fixme:
#segments=($GIT_DIR/refs/base/*)

# this list_segments is also in `git-segment'
segments=($(git for-each-ref 'refs/base/' --format "%(refname)" |\
            sed -e 's|^refs/base/||'))

if [ 0 =  ${#segments} ]; then
    echo "no segments." >&2
else
  foreach segment ($segments);
  {
	echo -n $(basename $segment) "\t"; segment_base $segment
  }   > $GRAPH
fi



# sums
typeset -a sums
sums=$(list_sums )

if [ 0 = ${#sums} ]; then
    echo "no sums." >&2
else
    foreach sum ($sums)
    {
	name=$(basename $sum)
	(while read a; do
	    echo $name "\t" $a
	    done ) < $sum;
    } >> $GRAPH
fi

# sort.



if [ $just_graph = y ]; then
    # while read
    for  a in $(tsort $GRAPH)
    do
	cecho green $a
	grep -e "^$a" $GRAPH || true
    done
else
    tsort $GRAPH | tac
fi


if [ $keep_graph != y ]; then
    rm -f $GRAPH
else
    echo "graph left in: $GRAPH" >&2
fi
