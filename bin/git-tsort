#! /usr/bin/zsh -feu

# Generate list of my known branches (sums & segments)
# and output them in topological order.

# note this generates the graph "globally", not by search.

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

keep_graph_file="n"
just_graph=n
dot_format=n
debug=n
typeset -a draw_options

usage()
{
cat <<EOF
usage: ${0##*/} [+-k]  [-g] [-x] [--]
-x display using  dot(1)
-k keep the generated file (for tsort(1))

-g don\'t dump the topological order on stdout.
EOF
}

while getopts :kgxd OPT; do
    case $OPT in
	k|+k)
	    keep_graph_file=y
	    draw_options+=(-k)
	    ;;
	g)
	    just_graph=y
	    ;;
	d)
	    debug=y
	    ;;
	x)
	    dot_format=y
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1

# Get a temp file:
# generate
GRAPH=$(mktemp --tmpdir=${TEMP-/run/tmp/}  graph.XXX)
extern_color=pink

# segments ... look at bases.
setopt NULL_GLOB

typeset -a segments
# fixme:
#segments=($GIT_DIR/refs/base/*)

# this list_segments is also in `git-segment'
segments=($(git for-each-ref 'refs/base/' --format "%(refname)"))
if [ 0 =  ${#segments} ]; then
    echo "no segments." >&2
else
  foreach segment ($segments);
  {
      # mmc: why not output the full base ref?
      name=${segment#refs/base/}
      if [ $dot_format = y ];
      then
	  dot_name=${name//-/_}
	  # todo:  #
	  slash="/"
	  base_name=${$(segment_base $name)#refs/heads/}
	  dot_base_name=${${${base_name#refs/remotes/}//-/_}//$slash/_}

	  echo "$dot_name -> $dot_base_name"

	  local age=$(segment_age $name)
	  local length=$(segment_length $name)
	  local color
	  if [ $age = 0 ];then
	      color=yellow
	  else
	      color=orange
	  fi
	  cat <<EOF
$dot_name [label="$name $length\n$age",color=$color,fontsize=14,
	      fontname="Palatino-Italic",fontcolor=black,style=filled];
EOF

          if ! git-segment $base_name &>/dev/null ; then
	      if ! git-sum $base_name &>/dev/null; then
		  cat <<EOF
$dot_base_name [label="$base_name",color=$extern_color,fontsize=14,
	      fontname="Palatino-Italic",fontcolor=black,style=filled];
EOF
	      fi
	  fi

      else
	  # for tsort:
	  echo -n refs/heads/$name "\t";
	  segment_base $name
      fi
  }   > $GRAPH
fi


# sums
typeset -a sums
sums=($(list_sums))

if [ 0 = ${#sums} ]; then
    test $debug = y && echo "no sums." >&2
else
    foreach sum ($sums)
    {

	git for-each-ref "refs/sums/$sum/" --format "%(refname)" |\
	(while read a; do
	    if [ $dot_format = y ];
	    then
		echo -n ${sum//-/_} "->";
		echo ${${$(dump_ref $a|sed -e 's/^ref:\s//')#refs/heads/}//-/_}
	    else
		# for tsort:
		echo -n "refs/heads/$sum" "\t"; dump_ref $a|sed -e 's/^ref:\s//'
	    fi
	    done )

	if [ $dot_format = y ]; then
            cat <<EOF
${sum//-/_} [label="$sum",color=red,fontsize=14,
	      fontname="Palatino-Italic",fontcolor=black,style=filled];
EOF
        fi
    } >> $GRAPH
fi



if [ $dot_format = y ]; then
    draw-tsort-graph $draw_options -F png $GRAPH | display -
    #dot -Tpng  $GRAPH
    #rm $GRAPH
elif [ $just_graph = y ]; then
    # sort:

    # while read
    for  a in $(tsort $GRAPH)
    do
	cecho green $a
	grep -e "^$a" $GRAPH || true
    done
else
    tsort $GRAPH | tac
fi


if [ $keep_graph_file != y ]; then
    rm -f $GRAPH
else
    echo "graph left in: $GRAPH" >&2
fi
