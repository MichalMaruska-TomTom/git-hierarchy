#!/bin/zsh -feu
source /usr/share/git-hierarchy/functions.sh


usage()
{
    cat <<EOF
usage: ${0##*/} [+-h] [--]  {segment} {commit} {new-name}

*************
Given a segment, split it into 2 segments:
The new one is the _TOP_ half of the existing.

base/start .... segment (commit) .... new-name
EOF
}


while getopts :h OPT; do
    case $OPT in
        h|+h)
            usage
            exit 0
            ;;
        *)
            # wrong option
            usage >&2
            exit 1
    esac
done
shift OPTIND-1
OPTIND=1


if [[ $# != 3 ]]; then
    usage >&2
    exit 1
fi

set -x
readonly segment=$1
readonly commit=$2
# must be inside the segment! todo: check it!

# git rev-parse $commit
git merge-base --is-ancestor start/$segment $commit
git merge-base --is-ancestor $commit $segment

readonly name=$3
# upper one?

# The upper part: -- notice it temporarily has the base ABOVE the start:
git-segment $name $segment $commit $segment


# now cut the bottom part:
if [[ $(current_branch_name) = $segment ]]; then
    git switch $name
fi

git branch -f $segment $commit

# git-rename $se
# git-segment $3 ($git-base $segment)
