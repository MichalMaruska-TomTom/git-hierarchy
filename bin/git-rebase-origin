#!/bin/zsh -feu

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)
cd "$(git rev-parse --show-toplevel)"


# I could even 'git fetch'
usage()
{
    cat <<EOF
usage: ${0##*/} [+-hfv] [--] [top-ref]
-f  do NOT git fetch origin
-v  verbose
-d  dry
[top-ref]  what to rebase, by default the current branch.

Discover which remote branches to fetch, then rebase ....
EOF
}

DEBUG()
{
    if [ $DEBUG = y ]; then
        cecho blue "$@" >&2
    fi
}

INFO()
{
    cecho blue "$@" >&2
}

DEBUG=n
fetch=yes
dry_only=no

# if only debian/changelog -> stash
while getopts :hfvd OPT; do
    case $OPT in
        h|+h)
            usage
            exit 0
            ;;
        d)
            dry_only=yes
            ;;
        f)
            fetch=no
            ;;
        v)
            DEBUG=y
            ;;
        *)
            usage
            exit 2
    esac
done
shift $(( OPTIND - 1 ))
OPTIND=1
if [ $# -lt 1 ]; then
    # by default the current-branch-poset
    # by default look at the base ... what it follows:
    top=$(current_branch_poset)
    INFO "taking the current $top as top"
elif [ $# = 1 ]; then
    top=$1
else
    die "wrong number of parameters"
fi

# todo: git-walk-down and solve the baseS. move them,
typeset -a bases
#todo: have to
git checkout HEAD

bases=($(git-walk-down -r $top|sed -n -e '/^base: /s///p'))

GIT_P4=~/git/git-core/git-p4.py

DEBUG "bases: $bases"

# uses $dry_only, $fetch, $GIT_P4
function rebase_one()
{
    local -r base=$1
    local remote
    local git_fetch=$fetch
    local REMOTE_BRANCH

    if expr match $base 'refs/remotes/p4/' >/dev/null ;
    then
        remote=${base#refs/remotes/p4/}
        REMOTE_BRANCH=${remote}
        if [ $dry_only = no ]; then
            # readonly
            set -x
            local -r old=$(git rev-parse ${base#refs/})
            $GIT_P4 sync --branch $REMOTE_BRANCH --git-dir $(git rev-parse --git-common-dir)
            git log $old..${base#refs/}
        fi
        git_fetch=no
    elif expr match $base 'refs/remotes/' >/dev/null ;
    then
        remote=${base#refs/remotes/}
        remote_branch=${remote#*/}
        remote=${remote%/*}
    else
        #fixme:
        this_branch=$base
        base=refs/heads/$base

        remote_branch=$(git for-each-ref --format='%(upstream:short)' $base)

        remote=${remote_branch%/*}
        remote_branch=${remote_branch#*/}
    fi

    if [ $git_fetch = yes ]; then
        INFO "Fetching upstream to $base: $remote"
        if [ $dry_only = no ]; then
            local -r old1=$(git rev-parse $remote/$remote_branch)
            git fetch $remote $remote_branch
            git log $old1..FETCH_HEAD
        else
            echo "would fetch from $remote $remote_branch"
        fi
    fi # manual! todo: understand what error scenarios are possible!

    # sometimes I point the the segment base directly at remote, correct?
    if [ $dry_only = no ]; then
        if [ -n "${this_branch-}" ]; then
            set_branch_to $this_branch $remote/$remote_branch
        fi
    fi
}


foreach base ($bases)
{
    rebase_one $base
}
#$2
# origin/$base
if [ $dry_only = no ]; then
    git-rebase-poset $top
fi
