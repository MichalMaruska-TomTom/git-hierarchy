#!/bin/zsh -feu

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

# I could even 'git fetch'
usage()
{
    cat <<EOF
usage: ${0##*/} [+-hfv] [--] [ {top-ref} ]
-f  do NOT git fetch origin
-v  verbose
-d  dry
EOF
}

DEBUG=n
fetch=yes
dry_only=no

# if only debian/changelog -> stash
while getopts :hfvd OPT; do
    case $OPT in
	h|+h)
	    usage
	    exit 0
	    ;;
	d)
	    dry_only=yes
	    ;;
	f)
	    fetch=no
	    ;;
	v)
	    DEBUG=y
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift $(( OPTIND - 1 ))
OPTIND=1

if [ $# -lt 1 ]; then
    # by default the current-branch-poset
    # by default look at the base ... what it follows:
    top=$(current_branch_poset)
    cecho yellow "taking the current $top" >&2
else
    top=$1
fi




# todo: git-walk-down and solve the baseS. move them,
typeset -a bases
#todo: have to
git checkout HEAD

bases=($(git-walk-down -r $top|sed -n -e '/^base: /s///p'))
foreach base ($bases)
{
    if expr match $base 'refs/remotes/'; then
	remote=${base#refs/remotes/}
	remote_branch=${remote#*/}
	remote=${remote%/*}
    else
	#fixme:
	base=refs/heads/$base
	this_branch=$base

	remote_branch=$(git for-each-ref --format='%(upstream:short)' $base)

	remote=${remote_branch%/*}
	remote_branch=${remote_branch#*/}
    fi

    if [ $fetch = yes ]; then
	[ $DEBUG = y ] && cecho blue "Fetching upstream to $base: $remote"
	if [ $dry_only = no ]; then
	    set -x
	    git fetch $remote $remote_branch
	else
	    echo "would fetch from $remote $remote_branch"
	fi
    fi # manual! todo: understand what error scenarios are possible!

    # sometimes I point the the segment base directly at remote, correct?
    if [ $dry_only = no ]; then
	if [ -n "${this_branch-}" ]; then
	    git branch -f $this_branch $remote/$remote_branch
	fi
    fi
}
#$2
# origin/$base
if [ $dry_only = no ]; then
    git-rebase-poset $top
fi

