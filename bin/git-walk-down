#! /usr/bin/zsh -feu
extern_color=pink

# Tools can operate in 2 modes: `set' mode, in which ALL segments & sums are collected,
# and t-sorted by _local_ property of incidence.
#
# or the `graph' mode, in which some root(s) is given, and we walk down and get a restricted
# set of segments/sums.
#
# DISPlay etc should be separate. These 2 methods should feed a commot format of data.


# apparently I use 2 formats:  `dot' and `tsort'


# old: This is .... unmaintained.... the display part is left behind git-tsort -x.

# fixme: this does not dump the TYPE of the relationship. (sum vs segment-base)
source /usr/share/git-hierarchy/functions.sh

usage()
{
    setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [-g | x | r | l | s] | [-f format]  [-dh] [--] {REF}

Output or Display the order of segments & sums below REF

Format:
-g  dump the graph (default)
-r  raw format
-x  display the graph w/ ImageMagick
-l  log with --graph
-s  symbolic

-f  format --- explicitly select (dot raw tsort)

-i ignore broken defition

-d  turn on Debugging

-k keep the graph file
-h  help

REF ... top segment/sum
EOF
    unsetopt POSIX_ARGZERO
}

display_gui=n

dump_format=tsort
segment_format=$dump_format

keep_graph=n
verbose=n
debug=n
typeset -a draw_options


while getopts :df:ghi:klrstx OPT; do
    case $OPT in
        x|+x)
            display_gui=y
            dump_format=dot
            segment_format=$dump_format
            ;;
        k)
            keep_graph=y
            ;;
        i)
            known_divergent+=($OPTARG)
            ;;
        t)
            segment_format=tsort
            dump_format=raw
            ;;
        g|+g)
            dump_format=tsort
            segment_format=$dump_format
            ;;
        r|+r)
            dump_format=raw
            segment_format=$dump_format
            ;;
        s)
            dump_format=symbolic
            segment_format=$dump_format
            ;;
        l)
            segment_format=tsort
            dump_format=log
            ;;
        f)
            dump_format=$OPTARG
            segment_format=$dump_format
            ;;
        h|+h)
            usage
            exit 0
            ;;
        d)
            debug=y
            verbose=y
            ;;
        *)
            usage
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1

if [ $# = 0 ]; then
    # default is the current branch
    ref_name=$(git rev-parse --symbolic-full-name HEAD)
elif [ $# = 1 ]; then
    ref_name=$1
else
    usage >&2
    exit 1
fi

ref_name=${ref_name#refs/heads/}

GRAPH=

trap "clean" EXIT
clean()
{
    if [[ $keep_graph = n ]]; then
        test -n "$GRAPH" && rm -f $GRAPH
    fi
}

GRAPH=$(mktemp -t graph.XXX)

sum_format=$segment_format
walk_down_from $ref_name $segment_format $sum_format > $GRAPH

# cat $GRAPH

# same as git-graph:
case $dump_format in
    dot)
        draw-tsort-graph $draw_options -F png $GRAPH | display -
        ;;
    raw | symbolic)
        cat $GRAPH
        ;;
    log)
        find_roots_and_tops $GRAPH

        for ((i=1; i<= ${#roots}; i++))
            {echo $i $roots[$i];
             roots[$i]="$roots[$i]^!";
             echo $roots[$i]
            }

        git log --graph --oneline --decorate $roots $tops
        ;;
    tsort)
        tsort $GRAPH | tac
        ;;
    *)
        for  a in $(tsort $GRAPH)
        do
            cecho green $a
            grep -e "^$a" $GRAPH || :
        done

esac
