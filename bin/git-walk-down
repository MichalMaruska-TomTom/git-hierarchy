#! /usr/bin/zsh -feu


# Tools can operate in 2 modes: `set' mode, in which ALL segments & sums are collected,
# and t-sorted by _local_ property of incidence.
#
# or the `graph' mode, in which some root(s) is given, and we walk down and get a restricted
# set of segments/sums.
#
# DISPlay etc should be separate. These 2 methods should feed a commot format of data.


# apparently I use 2 formats:  `dot' and `tsort'


# old: This is .... unmaintained.... the display part is left behind git-tsort -x.

# fixme: this does not dump the TYPE of the relationship. (sum vs segment-base)
source /usr/share/git-hierarchy/functions.sh

# segment_base ${segment#refs/base/}

usage()
{
    setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [+-dghxr] [--] {root-ref}

Output or Display the order of segments & sums below REF
-x  display the graph w/ ImageMagick
-g  dump the graph
-r  raw format
-l  log with --graph
-d  turn on Debugging

-k keep the graph file
-h  help
EOF
    unsetopt POSIX_ARGZERO
}

# sum_bases()
display_gui=n
dump_format=tsort
extern_color=pink
keep_graph=n
verbose=n
DEBUG=n
typeset -a draw_options


while getopts :dghklxr OPT; do
    case $OPT in
        x|+x)
            display_gui=y
            dump_format=dot
            segment_format=$dump_format
            ;;
        k)
            keep_graph=y
            ;;
        g|+g)
            dump_format=tsort
            segment_format=$dump_format
            ;;
        r|+r)
            dump_format=raw
            segment_format=$dump_format
            ;;
        l)
            segment_format=tsort
            dump_format=log
            ;;
        h|+h)
            usage
            exit 0
            ;;
        d)
            DEBUG=y
            verbose=y
            ;;
        *)
            usage
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1

if [ $# = 0 ]; then
    # default is the current branch
    ref_name=$(git rev-parse --symbolic-full-name HEAD)
elif [ $# = 1 ]; then
    ref_name=$1
else
    usage >&2
    exit 1
fi

ref_name=${ref_name#refs/heads/}
root=$ref_name

GRAPH=

trap "clean" EXIT
clean()
{
    if [[ $keep_graph = n ]]; then
        test -n "$GRAPH" && rm -f $GRAPH
    fi
}

GRAPH=$(mktemp --tmpdir=${TEMP-/run/tmp/} graph.XXX)

# DFS:
typeset -a queue
queue=($root)
typeset -a processed
while [[ ${#queue} -ge 1  ]];
do

    this=${queue[1]}
    # remove "first" if it's repeated:
    # we don't need += here, since all previously processed cannot be in `queue' anymore,
    # if the graph is DAG (acyclic!):
    processed=($this)

    queue=(${queue:|processed})# A:|B is A-B. fixme: processed ?
    # take the first, and append the base(s)
    # also remove "first" if it's repeated.

    test "$DEBUG" = y && \
        cecho yellow "processing $this, remain $queue ${#queue}" >&2 || : ok

    # append the base(s), or summands:
    name=${this#refs/heads/}
    if is_sum $name; then
        # fixme:
        dump_sum $segment_format $name
        queue+=($(summands_of $name))
    elif is_segment $name; then
        dump_segment $segment_format $name
        queue+=($(segment_base $name))
    else
        if test "$DEBUG" = y; then
            cecho red "stopping @ $name" >&2
        fi
        if [ $dump_format = raw ]; then
            echo "base: $name"
        fi
    fi

    if test "$DEBUG" = y; then
        cecho green "iterate $queue -- ${#queue}" >&2
    fi
done  > $GRAPH


# cat $GRAPH

# same as git-tsort:
case $dump_format in
    dot)
        draw-tsort-graph $draw_options -F png $GRAPH | display -
        ;;
    raw)
        cat $GRAPH
        ;;
    log)
        find_roots_and_tops $GRAPH

        for ((i=1; i<= ${#roots}; i++))
            {echo $i $roots[$i];
             roots[$i]="$roots[$i]^!";
             echo $roots[$i]
            }

        git log --graph --oneline --decorate $roots $tops
        ;;
    tsort)
        tsort $GRAPH | tac
        ;;
    *)
        for  a in $(tsort $GRAPH)
        do
            cecho green $a
            grep -e "^$a" $GRAPH || :
        done

esac
