#! /usr/bin/zsh -feu

# This is .... unmaintained.... the display part is left behind git-tsort -x.
#
source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

# segment_base ${segment#refs/base/}

usage()
{
    cat <<EOF
usage: ${0##*/} [+-xgh} [--] {root-ref}

Output or Display the order of segments & sums below REF
-x  display the graph w/ ImageMagick
-g  dump the graph

EOF
}

# sum_bases()
display_gui=n
just_graph=n
dot_format=n
extern_color=pink
DEBUG=n
typeset -a draw_options


while getopts :dghx OPT; do
    case $OPT in
	x|+x)
	    display_gui=y
	    dot_format=y
	    ;;
	g|+g)
	    just_graph=y
	    ;;
	h|+h)
	    usage
	    exit 0
	    ;;
	d)
	    DEBUG=y
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1

if [ $# != 1 ]; then
    usage
    exit 1
fi


root=$(git-expand-ref $1)


GRAPH=$(mktemp --tmpdir=${TEMP-/run/tmp/}  graph.XXX)

# DFS:

typeset -a queue
queue=($root)
typeset -a processed
while [[ ${#queue} -ge 1  ]];
do

    this=${queue[1]}
    # we don't need += here:
    processed=($this)
    queue=(${queue:|processed})# fixme: processed ?
    # take the first, and append the base(s)
    # also remove "first" if it's repeated.


    test "$DEBUG" = y && \
	cecho yellow "processing $this, remain $queue ${#queue}" >&2 || : ok

    name=${this#refs/heads/}
    if is_sum $name; then
	dump_sum $name
	queue+=($(summands_of $name))
    elif is_segment $name; then
	dump_segment $name
	queue+=($(segment_base $name))
    else
	if test "$DEBUG" = y; then
	    cecho red "stopping @ $name" >&2
	fi
    fi

    if test "$DEBUG" = y; then
	cecho green "iterate $queue -- ${#queue}" >&2
    fi
done  > $GRAPH


# cat $GRAPH

# same as git-tsort:
if [ $dot_format = y ]; then
    draw-tsort-graph $draw_options -F png $GRAPH | display -
    #dot -Tpng  $GRAPH
    #rm $GRAPH
elif [ $just_graph = y ]; then
    # sort:

    # while read
    for  a in $(tsort $GRAPH)
    do
	cecho green $a
	grep -e "^$a" $GRAPH || :
    done
else
    tsort $GRAPH | tac
    # rm $GRAPH
fi


