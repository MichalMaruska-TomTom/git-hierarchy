#! /usr/bin/zsh -feu

# this tool invokes linearily (in sequence) rebasing operations (or merging),
# in future possibly "git fetch".

# IOW: iterates in topological order over
#         segments
#         sums.

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)
cd "$(git rev-parse --show-toplevel)"

usage()
{
    setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [+-h] [-d] [-n] [--]  [sum|segment] ...
-d debug

-n .. dry


-s old-name
-t new-name
Replace old-name as summands/segment-bases with new-name.
EOF
    unsetopt POSIX_ARGZERO
}

DEBUG=n
dry_only=n
skip_over=""

while getopts :hdns:t: OPT; do
    case $OPT in
        d) DEBUG=y
           set -x
           ;;
        n)
            dry_only=y
            ;;
        s)
            # ref = another_ref
            skip_over=$(expand_ref $OPTARG)
            ;;
        t)
            replacement=$(expand_ref $OPTARG)
            #"master"
            ;;
        h|+h)
            usage
            exit
            ;;
        *)
            usage
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1


# check, that no other rebase in progress
# check consistency:
if [ -e $GIT_DIR/.rebasing-segment ]; then
    cecho red "Must first finish rebasing segment " \
        "$(cat $GIT_DIR/.rebasing-segment)"
    exit -1
fi


stash_if_non_clean "git-rebase-poset"

typeset -a WHAT_TO_REBASE

if [ $# -gt 0 ]; then
    test "$DEBUG" = y && {echo -n "... down from ";cecho cyan "$1"} >&2
    WHAT_TO_REBASE=($(git-walk-down -g $1))
else
    WHAT_TO_REBASE=($(git-graph -t))
fi

# Log in .git/
mark_rebase_poset $WHAT_TO_REBASE


typeset -a GIT_DEBUG_OPTIONS
GIT_DEBUG_OPTIONS=()

test "$DEBUG" = y && GIT_DEBUG_OPTIONS+=(-d)
test "$DEBUG" = n && GIT_DEBUG_OPTIONS+=(-q)
#test "$SILENT" = y &&


log()
{
    if [[ $DEBUG = y ]]; then
        cecho red $1 >&2
    fi
}

report()
{
        cecho blue $1 >&2
}



is_summand()
{
    local sum=$1
    local ref=$2

    typeset -a summands
    summands=( $(summands_of $sum) )
    # echo "summands: $summands"
    [[ ${summands[(i)$ref]} -le ${#summands} ]]
}

# 
git-drop-in-hierarchy()
{
    local skip=$1
    local ref=$2
    local replacement=$3

    ref=$2
    name=${ref#refs/heads/}

    log "$skip vs ... $ref"

    if is_segment $name
    then
        log "$ref is segment"

        if [[ $skip == $ref ]]
        then
            log "skip over"
        elif [[ $skip = $(segment_base $name) ]]
        then
            if [[ $dry_only = y ]];
            then
                report "rebase $ref on $replacement"
            else
                git-segment -u $name $replacement
            fi
        else
            log "$skip unrelated to segment $ref"
        fi
    elif is_sum $name
    then
        if is_summand $name $skip
        then
            if [[ $dry_only = y ]];
            then
                report "remove $skip from sum $ref"
            else
                git-sum $name -$skip
            fi
        fi
    fi
}


foreach ref ($WHAT_TO_REBASE)
{
        # todo: create a tag, so that if `git-rebase' fails
        # at least I see the segment (in gitk).
        #
    test "$DEBUG" = y && cecho green "rebasing $ref"

    if [[ -n $skip_over ]]
    then
        git-drop-in-hierarchy $skip_over $ref $replacement
    else
        if [[ $dry_only = y ]];
        then
            echo "git-rebase-ref $ref"
        else
            if ! git-rebase-ref $GIT_DEBUG_OPTIONS $ref;
            then
                # todo: save continuation!
                #problem=$?
                problem=1
                cecho red "Failure on $ref: $?"
                # todo: list the path from .... poset root to this one
                exit $problem
            fi
        fi
    fi
}

unstash_if_stashed
