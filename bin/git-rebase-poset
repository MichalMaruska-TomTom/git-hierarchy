#! /usr/bin/zsh -feu

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)
move_only=n

usage()
{
    cat <<EOF
usage: ${0##*/} [+-h] [-d] [--] ARGS...
-d debug
EOF
}

DEBUG=n

while getopts :m:hd OPT; do
    case $OPT in
	m)
	    move_only=y
	    new_base=$OPTARG
	    ;;
	d) DEBUG=y
	    ;;
	h|+h)
	    usage
	    exit
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1


# check, that no other rebase in progress
if [ -e $GIT_DIR/.rebasing-segment ]; then
    cecho red "Must first finish rebasing segment " \
	"$(cat $GIT_DIR/.rebasing-segment)"
    exit -1
fi




typeset -a WHAT_TO_REBASE

if [ $# -gt 0 ]; then
    test "$DEBUG" = y && echo "... down from $1" >&2
    WHAT_TO_REBASE=($(git-walk-down $1))
else
    WHAT_TO_REBASE=($(git-tsort))
fi


if test $move_only = y;
then
    # find minimums
    minimal=()
    foreach ref ($WHAT_TO_REBASE)
    {
	if git-segment $ref > /dev/null; then
	    :
	elif git-sum $ref > /dev/null; then
	    :
	else
	    test "$DEBUG" = y && echo "non-rebaseable ref $ref" >&2
	    #
	    minimal+=($ref)
	fi
    }

    test "$DEBUG" = y && echo "bases: $minimal" >&2

    # exchange base new_base
    # if git-segment  -> base
    # git-segment -u $name $new_base
    graph=$(git-walk-down $ref)
    foreach min ($minimal)
    {
	min=${min#refs/heads/}
	test "$DEBUG" = y && cecho red "processing $min"
	foreach ref ($WHAT_TO_REBASE)
	{
	    ref=${ref#refs/heads/}
	    cecho blue "processing $ref  $(segment_base $ref)"

	    if git-segment $ref > /dev/null && \
		test $(segment_base $ref) = refs/heads/$min;
	    then
		echo git-segment -u $ref $new_base
		cecho green "should update segment $ref"
	    else
		# echo $(segment_base $ref)
	    fi
	}
    }
else
foreach ref ($WHAT_TO_REBASE)
{
    # todo: create a tag, so that if `git-rebase' fails
    # at least I see the segment (in gitk).
    #
    test "$DEBUG" = y && cecho green "rebasing $ref"

    if ! git-rebase-ref $ref;
    then
	problem=$?
	cecho red "Failure on $ref"
	exit $problem
    fi
}
fi
