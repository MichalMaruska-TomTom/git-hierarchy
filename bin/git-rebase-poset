#! /usr/bin/zsh -feu

# this tool invokes linearily (in sequence) rebasing operations (or merging),
# in future possibly "git fetch".
source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)
unsetopt FUNCTION_ARGZERO

usage()
{
    cat <<EOF
usage: ${0##*/} [+-h] [-d] [--]  [sum|segment] ...
-d debug
EOF
}

DEBUG=n

while getopts :hd OPT; do
    case $OPT in
	d) DEBUG=y
	    ;;
	h|+h)
	    usage
	    exit
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1


# I want 3 functions, and run the 2 iterators:
# process-base  process-segment  process-sum.
# and the iterators:
# git-walk-down
# git-tsort  (all)
# git-restore- ... same as tsort.



# check, that no other rebase in progress
if [ -e $GIT_DIR/.rebasing-segment ]; then
    cecho red "Must first finish rebasing segment " \
	"$(cat $GIT_DIR/.rebasing-segment)"
    exit -1
fi


typeset -a WHAT_TO_REBASE

if [ $# -gt 0 ]; then
    test "$DEBUG" = y && {echo -n "... down from ";cecho cyan "$1"} >&2
    WHAT_TO_REBASE=($(git-walk-down -g $1))
else
    WHAT_TO_REBASE=($(git-tsort))
fi


typeset -a GIT_DEBUG_OPTIONS
GIT_DEBUG_OPTIONS=()

test "$DEBUG" = y && GIT_DEBUG_OPTIONS+=(-d)
test "$DEBUG" = n && GIT_DEBUG_OPTIONS+=(-q)
#test "$SILENT" = y &&

foreach ref ($WHAT_TO_REBASE)
{
	# todo: create a tag, so that if `git-rebase' fails
	# at least I see the segment (in gitk).
	#
    test "$DEBUG" = y && cecho green "rebasing $ref"

    if ! git-rebase-ref $GIT_DEBUG_OPTIONS $ref;
    then
	# todo: save continuation!
	#problem=$?
	problem=1
	cecho red "Failure on $ref: $?"
	# todo: list the path from .... poset root to this one
	exit $problem
    fi
}
