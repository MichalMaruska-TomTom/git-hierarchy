#! /usr/bin/zsh -fue
usage()
{
    # print "usage: ${0##*/} [+-h} [--] ARGS..."
    echo ""
}

while getopts :h OPT; do
    case $OPT in
	h|+h)
	    usage
	    exit 0
	    ;;
	*)
	    usage >&2
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1

from=$1
new=$2

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

# this renames only branches!

full_from=$(git-expand-ref $from)
# fixme!
# or refs/heads/$from

# fixme! it might not exist yet!
full_new=$new
# $(git-expand-ref $new)
# $new

from=${full_from#refs/heads/}
new=${full_new#refs/heads/}

# fixme: verify that it's a branch name.

# quoted_regexp.

# replace....
echo renaming $from to $new

git branch -m $from $new || true
# todo: trap


rename_symbolic_reference()
{
    ref=$1
    new_name=$2
    # git symbolic-ref -m "renaming Sum"

    # rename: create & drop?
    content=$(dump_ref $ref)
    # fixme: if hash don't prepend "ref:" !!!

    set_symbolic_reference $new_name $content
    git update-ref --no-deref  -d $ref
}



# rename sum:
if is_sum $from; then
    # rename ALL refs
    git for-each-ref "refs/sums/$from/" --format "%(refname)"|\
    while read summand; do
	index=${summand##*/}
	rename_symbolic_reference $summand "refs/sums/$new/$index"
    done
fi

# rename segment:
# segment base/start refs.
if is_segment $from; then
    rename_symbolic_reference refs/base/$from refs/base/$new
    rename_symbolic_reference refs/start/$from refs/start/$new
fi




# as the destination of a symref.
full_new=$(git-expand-ref $new)

git for-each-ref "refs/sums/" "refs/base/" --format "%(refname)"|\
while read symref; do
    if dump_ref $symref|\
       grep --line-regexp --fixed-strings "ref: $full_from" >/dev/null
    then
       set_symbolic_reference $symref "ref: $full_new"
    fi
done


exit

# fixme: not remotes!
QUOTED_REGEXP=$from
# other bases pointing at this branch.

setopt extendedglob
foreach ref ($GIT_DIR/refs/^remotes/**/*(.))
{
    sed -i -e "s|ref: refs/heads/$QUOTED_REGEXP|ref: refs/heads/$new|g" $ref
}


