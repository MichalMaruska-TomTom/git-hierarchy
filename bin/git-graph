#! /usr/bin/zsh -feu

# Generate list of my known branches (sums & segments)
# and output them in topological order.

# note this generates the graph "globally", not by search.

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

keep_graph_file="n"
just_graph=n

dump_format=log
segment_format=tsort
verbose=n
typeset -a draw_options

DEBUG=no
usage()
{
    setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [+-k]  choose-format  [--]
-i ignore mis-alignment

-x display using  dot(1)

-t just dump the tsort lines
  -g don\'t dump the topological order on stdout.

-k keep the generated file (for tsort(1))

Format:
-g
-x   Xdot
-l   git log
-r   resolved
-s   symbolic
-t
EOF
    unsetopt POSIX_ARGZERO
}

while getopts :dgi:klrstx OPT; do
    case $OPT in
        d)
            verbose=y
            ;;
        g)
            just_graph=y
            ;;
        i)
            known_divergent+=($OPTARG)
            ;;
        k|+k)
            keep_graph_file=y
            draw_options+=(-k)
            ;;
        l)
            dump_format=log
            segment_format=tsort
            ;;
        r)
            dump_format=resolved
            segment_format=resolved
            ;;
        s)
            dump_format=symbolic
            segment_format=symbolic
            ;;
        t)
            dump_format=tsort
            ;;

        x)
            dump_format=dot
            segment_format=dot
            ;;
        *)
            usage
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1

readonly GRAPH=$(mktemp -t graph.XXX)
extern_color=pink

# segments ... look at bases.
setopt NULL_GLOB

# why temp file?
# tsort doesn't need it (- is ok)
# my ../../mmc-shell/bin/draw-tsort-graph
# this could be tsort-ed. But this ^ sort it too.


# only 1?
if [ $# -gt 1 ]; then
    usage >&2
    exit 1
elif [ $# = 0 ]; then
    # default:
    # fixme: this must SORT topologically!
    dump_whole_graph_tsort $segment_format > $GRAPH
else
    ref_name=$1
    ref_name=${ref_name#refs/heads/}
    # ref_name=$(git rev-parse --symbolic-full-name "HEAD")

    # title="full down from $ref_name"
    sum_format=$segment_format
    walk_down_from $ref_name $segment_format $sum_format > $GRAPH
    # git-walk-down -f $segment_format $ref_name > $GRAPH
fi


# now the action -- the format of the file is not changed anymore
case $dump_format in
    dot)
        draw-tsort-graph $draw_options -F png $GRAPH | display -
        #dot -Tpng  $GRAPH
        #rm $GRAPH
        ;;
    symbolic)
        cat $GRAPH
        ;;
    resolved)
        # fixme?
        cat $GRAPH
        ;;
    log)
        find_roots_and_tops $GRAPH

        for ((i=1; i<= ${#roots}; i++))
            {
                # echo $i $roots[$i];
                roots[$i]="$roots[$i]^!";
                # echo $roots[$i]
            }
            git log --graph --oneline --decorate $roots $tops
        ;;
    *)
        if [ $just_graph = y ]; then
            # sort:

            # while read
            for a in $(tsort $GRAPH)
            do
                cecho green $a
                grep -e "^$a" $GRAPH || true
            done
        else
                tsort $GRAPH | tac
        fi

esac


if [ $keep_graph_file != y ]; then
    rm -f $GRAPH
else
    echo "graph left in: $GRAPH" >&2
fi
