#! /usr/bin/zsh -feu

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

usage()
{
    cat <<EOF
usage: ${0##*/} [+-h} [--] branch symbolic-base [current-base]

EOF
}


delete=n
delete_branch=n


while getopts :hdD OPT; do
    case $OPT in
	h|+h)
	    usage
	    exit 0
	    ;;
	d)
	    delete=y
	    ;;
	D)
	    delete=y
	    delete_branch=y
	    ;;
	*)
	    print "usage: ${0##*/} [+-h} [--] ARGS..."
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1



## `list' all segments:
if [ $# = 0 ]; then
    foreach segment ($GIT_DIR/refs/base/*(:t)) {echo $segment}
    exit 0;
fi


name=$1
basefile=$GIT_DIR/refs/base/$name
startfile=$GIT_DIR/refs/start/$name

describe_segment()
{
    base=$(cat $basefile| sed -e 's/^ref: //' | sed -e 's|^refs/heads/||')
    cecho green $base
    cat $startfile
}


if [ $# = 1 ]; then
    if [ $delete = y ]; then

	describe_segment || true
	rm -vf $startfile || rm -vf $basefile || true
	## necessary?
	if [ $delete_branch = y ];then
	    git branch -d $name
	fi
    else
    ## `Describe' the (given) segment
    # cat $basefile
    # could be hash
    # or ref - tag or head.
	describe_segment
    fi
else

    # `update/setup' the segment definition
    from=$2

    # User specified -> official:
    base=$(git show-ref $from|head -n 1|cut -f 2 -d ' ')
    cecho yellow "so the base is $base"

    if [ $# -ge 3 ]; then
	# fixme: this is a pattern.
	#refs/heads/master
	if git show $3 > /dev/null;
	then
	    start=$3
	else
	    start=$(git show-ref --hash $3)
	fi
    else
	start=$(git show-ref --hash $from)
	#if [ ${start} -gt 1 ]; then error;fi
    fi
    cecho yellow "so the start is $start"
    # git show $start

    # branch_exists $name
    [ -e $GIT_DIR/refs/heads/$name ] || git branch $name $start

    mkdir -p $(dirname $basefile) $(dirname $startfile)
# canonize:
    echo "ref: $base" > $basefile
    echo $start > $startfile
fi
