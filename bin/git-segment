#! /usr/bin/zsh -feu

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

if getopt -T; then # should test (( $? = -4 ))
    echo "incompatible  getopt(1) installed. Abort"
    exit -1
fi

PROGRAM=${0##*/}


usage()
{
    cat <<EOF
usage:
$PROGRAM [-s| --short]
  List the segments, -s short-format

$PROGRAM {segment-name}
  Show the definition & dump the commits/history
$PROGRAM [-d | --delete | -D | -prune] name
  Delete the definition, and even the branch itself.

$PROGRAM -r {segment} {start}
  set the start

$PROGRAM [-u | --update ] {segment} symbolic-base [start]
  update

$PROGRAM {segment} symbolic-base [start]
  define

EOF
}

describe_segment()
{
    local name=$1
    local baseref=refs/base/$name
    local startref=refs/start/$name
    #$baseref

    # fixme: how to avoid dereferencing?
    # git show-ref $startref

    local base=$(dump_ref $baseref |\
           sed -e 's/^ref: //' | sed -e 's|^refs/heads/||')
    cecho green $base

    git show-ref --hash $startref

    # how many commits there?
    local count=$(git log --oneline $startref..heads/$name |wc --lines)
    echo $count commits:
    git log --oneline $startref..heads/$name
}

list_segments(){
    # todo short_list as parameter?
    git for-each-ref 'refs/base/' --format "%(refname)" |\
        sed -e 's|^refs/base/||' |\
    while read segment;
    do
	echo -e -n $segment
	if [ $short_list = n ]; then
	    echo -en "\t\t";
	    echo ${$(dump_ref_without_ref "refs/base/$segment")#refs/heads/}
	else
	    echo
	fi
    done
}

delete_segment=n
delete_branch=n
short_list=n

update=n
restart=n

typeset -a cmd_options
cmd_options=( $(getopt --name $0 --shell bash \
	--longoptions help,short,delete,prune,update:,restart \
        --options     hsdDur \
	-- "$@" )) || { usage && exit 1 }

while (( ${#cmd_options} > 0 )); do
    case $cmd_options[1] in
	-h | --help)
	    usage
	    exit 0
	    ;;
	-s | --short)
	    short_list=y
	    ;;
	-d | --delete)
	    delete_segment=y
	    ;;
	-D | --prune )
	    delete_segment=y
	    delete_branch=y
	    ;;
	-u | --update)
	    update=y
	    ;;
	-r | --restart)
	    restart=y
	    # new_start=$OPTARG
	    ;;
    esac
    shift cmd_options
done

# set the positional params
set -- $cmd_options



## `list' all segments, and the Bases.
if [ $# = 0 ]; then
    list_segments

    # Dump the starts?
    if false; then
	echo
	git for-each-ref 'refs/start/' --format "%(refname)" |\
            sed -e 's|^refs/start/||'
    fi
    exit 0;
fi


# Otherwise a specific segment:
name=$1
baseref=refs/base/$name




if [ $# = 1 ]; then
    if [ $delete_segment = y ]; then

	echo "use git-delete(1)"
	exit 1

	describe_segment $name|| true

        # git update-ref -d  refs/base/test "refs/heads/master"
        # removes master!

	# funny: bug!
	drop_segment $victim

	## necessary?
	if [ $delete_branch = y ];then
	    git-delete $name
	fi
    else
    ## `Describe' the (given) segment
    # cat $basefile
    # could be hash
    # or ref - tag or head.
	describe_segment $name
    fi
else
    # 4 options
    # 1/ defining (not updating)
    # 2/    possibly start=base

    # 3/ update  start
    # 4/         base  or both!

    # we have: new_start, new_base

    if [ $# = 2 ]; then
    # moving the `base'
	if [ $restart = y ]; then
	    new_start=$2
	    start_hash=$(git log $new_start --max-count=1 --format="%H")
	else
	    new_base=$2

	    if [ $update = n ]; then
		# default:
		start_hash=$(git log $new_base --max-count=1 --format="%H")
	    fi
	fi
    else
	new_base=$2
	# only in this case, there is this variable:
	start=$3
        # fixme: check that it's an ancestor (of segment's head)
	start_hash=$(git log $start --max-count=1 --format="%H")
    fi

    # note: that $start_hash is always defined, unless:   update & not restart
    # so the use of $start_hash below is correct:

    # Ensure it exists:
    if [ $update = y ]; then
	# check it exists
	if ! is_segment $name; then
	    die "unknown segment $name"
	fi
    else
	git-branch-exists $name || git branch $name $start_hash

	if is_segment $name; then
	    die "segment already exists: $name"
	fi
    fi


    echo "new: base: ${new_base-} start: ${new_start-}"

    # `update/setup' the segment definition
    # fixme: remove ""
    if [ -n "${new_base-}" ]; then
	new_base=$(git-expand-ref $new_base)
	cecho yellow "so the base is ${new_base-}"

	cecho yellow "Changing the base to $new_base"
	git symbolic-ref $baseref $new_base
    fi


    # User specified -> official:
    if [ -n "${start_hash-}" ]; then
	cecho yellow "so the start is $start_hash"
	git-set-start $name $start_hash
    fi


    #mkdir -p $(dirname $basefile) $(dirname $startfile)
    # canonize:
    #echo $start_hash > $startfile
fi
