#! /usr/bin/zsh -feu

usage()
{
    cat <<EOF
Remake a git sum-merge.

usage: ${0##*/} [-d] [+-r] [-h] [--] ARGS...
-d  dry
-r  reset (before starting merge)
-h  help
EOF
}

source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)

# fixme: some variable is used-before-defined
set +u
. /usr/lib/git-core/git-sh-setup
set -u
# todo:
# octopus can leave half work, so yes, I prefer:
require_clean_work_tree "merge" "$(gettext "Please commit or stash them.")"


# by default make a `clean' merge. This means
reset=y
dry=n
cmd=""

while getopts :rdh OPT; do
    case $OPT in
	d)
	    dry=y
	    cmd="cecho red"
	    ;;
	r)
	    # reset:
	    reset=y
	    ;;
	+r)
	    reset=n
	    ;;
	h)
	    usage
	    exit
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1

sum_branch=$1



#### Here we start:
typeset -a summand_branches

# get the list of summands:

summand_branches=(
    $(git for-each-ref "refs/sums/$sum_branch/" --format "%(refname)") )
#(${(f)_tmp})
# echo $summand_branches

# those references are symbolic "ref: ref/head/NAME", but we want to
# use the NAMES in the commit message & interaction with the user.
# So, `resolve' them:
typeset -a real_branches
real_branches=()

foreach br ($summand_branches) {
    # local
    name=$(dump_ref_without_ref $br)
    name=${name#refs/heads/}
    real_branches+=$name
    }
cecho blue "Summands: $real_branches"

git-branch-exists $sum_branch || git branch $sum_branch


# if exists such branch/tag ->abort
first=$real_branches[1]

others=($real_branches[2,-1])


######################################## Test if up-to-date
# take the branches' commit-ids
# and parent-ids of the sum's head.
# sort & compare
commit_ids_summands=()
foreach br ($summand_branches) {
    commit_ids_summands+=$(git rev-parse $br)
}
commit_ids_sum_parents=($(git show -s --format=format:"%P" $sum_branch))

equal=n
if test ${#commit_ids_sum_parents} = ${#commit_ids_summands}
then
    equal=y
    set +u # here we risk the "var. lookup" fails, so treat it explicitly
    # here the O(N^2) tests:
    foreach id ($commit_ids_summands) {
	if ! [[ ${commit_ids_sum_parents[(r)$id]} = $id ]] ; then
	    # if I had commit_ids_summands a hash, I could report
	    # the symbolic name!
	    cecho red "This one is not parent of the merge $id" >&2
	    equal=n
	else
	    # cecho green "found $id" >&2
	    :
	fi
    }
    set -u # here again we don't (intend to) risk it.
else
    cecho red "different number of summands: " \
	"${#commit_ids_sum_parents} != ${#commit_ids_summands}" >&2
fi

if test "$equal" = y;
then
    echo "no need to merge again -- the sum is up-to-date (as defined)." >&2
    exit 0
fi


####################################### Merge

if [ $reset = "y" ]; then
    #eval $cmd git checkout $sum_branch
    eval $cmd git checkout $first
    eval $cmd git branch -f $sum_branch $first
    eval $cmd git checkout $sum_branch
    # eval $cmd git reset --hard $first --
else
    eval $cmd git checkout $sum_branch
    eval $cmd git merge $first;
fi
# git checkout -b $sum_branch $first

# octopus is default (for >2 children) & refuses any conflict.

set -x
git merge -m "Sum: $sum_branch = $others + $first" \
    --rerere-autoupdate \
    -s octopus \
    -s recursive -X patience -X ignore-space-change $others


# foreach next ($others)
# {
#     eval $cmd git merge -m "'Sum: $next into $sum_branch'" --rerere-autoupdate $next;
# }

