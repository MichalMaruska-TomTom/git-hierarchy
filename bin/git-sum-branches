#! /usr/bin/zsh -feu

usage()
{
    cat <<EOF
Remake a git sum/merge.

usage: ${0##*/} [-d] [+-r] [-h] ..... [--] {sum}
-d  dry
-r  reset before starting merge. Default
+r  don't reset.
-h  help
.... can contain upstream Git(1) options.
EOF
}


source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)
# fixme:
cd $(git rev-parse --show-toplevel)


# by default make a `clean' merge. This means
reset=y
dry=n
cmd=""
debug=n

while getopts :rdhv OPT; do
    case $OPT in
	d)
	    dry=y
	    cmd="cecho red"
	    ;;
	r)
	    # reset:
	    reset=y
	    ;;
	+r)
	    reset=n
	    ;;
	h)
	    usage
	    exit
	    ;;
	v)
	    debug=y
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1

STASHED=no

# fixme: some variable is used-before-defined, in upstream code.
set +u
# this is run after processing the command line args. Otherwise -h would be
# handled by it
. /usr/lib/git-core/git-sh-setup
set -u
# todo:
# octopus can leave half work, so yes, I prefer:
if (require_clean_work_tree "merge" "$(gettext "Please commit or stash them.")")
then
    :
    # echo $?
#    exit 0
else
    cecho yellow "stashing for you..."
    git stash save "git-sum-branches saving"
    STASHED=yes
fi

if [ $# != 1 ]; then
    usage
    exit 1
fi

sum_branch=$1

#### Calculate the summands: for the check and for re-merging.
typeset -a summand_branches
summand_branches=(
    $(git for-each-ref "refs/sums/$sum_branch/" --format "%(refname)") )
#(${(f)_tmp})
#test $debug = y &&     echo $summand_branches

# Those references are symbolic "ref: ref/head/NAME", but we want to
# use the NAMES in the commit message & interaction with the user.
# So, `resolve' them:
typeset -a real_branches
real_branches=()

foreach br ($summand_branches) {
    # local
    name=$(dump_ref_without_ref $br)
    name=${name#refs/heads/}
    real_branches+=$name
    }

test $debug = y && echo "Summands: $real_branches"



######################################## Test if up-to-date
test_commit_parents()
# expects the $summand_branches variable.
# "returns" the $equal variable
{
# take the branches' commit-ids
# and parent-ids of the sum's head.
# sort & compare
    local commit_ids_summands
    commit_ids_summands=()
    foreach br ($summand_branches) {
	commit_ids_summands+=$(git rev-parse $br)
    }

    test $debug = y && echo "Summands: $commit_ids_summands" >&2
    commit_ids_sum_parents=($(git show -s --format=format:"%P" $sum_branch))


    test $debug = y && echo "Parents: $commit_ids_sum_parents" >&2

# new criterion:
# the parents "include" all summands, and each parent is one of the summands.
# that is, each parent is fast-forward of summands and a summand itself.
# fixme!

# how to get common base for merge:
# git merge-base

    equal=y

# 1/ each parent is one of summands.
# But, if the merge is itself one of summands -> should be ok!

    set +u # here we risk the "var. lookup" fails, so treat it explicitly

    local sum_id
    sum_id=$(git rev-parse $sum_branch)
    if [[ ${commit_ids_summands[(r)$sum_id]} = $sum_id ]];then
	test $debug = y && cecho red "This merge is itself a summand." >&2
    else
# here the O(N^2) tests:
	foreach id ($commit_ids_sum_parents) {
	    if ! [[ ${commit_ids_summands[(r)$id]} = $id ]] ; then
		test $debug = y && cecho red "This parent is not in summands: $id" >&2
		equal=n
	    else
		test $debug = y && cecho green "found $id" >&2
	    fi
	}
    fi
    set -u # here again we don't (intend to) risk it.

# if test $equal = y
# then
# 2/ each summand is less than the sum. not -> N
    foreach id ($commit_ids_summands) {
	#if still a chance to win:
	if test $id = $sum_id; then
	    test $debug = y && echo ignoring ;  # for example S=a+b  but b>a.
	else
	    if test $equal = y;
	    then
		equal=n
            # SOME of the parent covers it:
		foreach parent ($commit_ids_sum_parents) {
		    if test $(git merge-base $parent $id) = $id
		    then
			test $debug = y && cecho green "$parent is greater than $id" >&2
			equal=y
		    else
	    # cecho green "found $id" >&2
			:
		    fi
		}
	    else
	    # no need to check further
		break;
	    fi
	fi
    }

}

restore_stash()
{
    if [ $STASHED = yes ]; then
	cecho yellow "unstashing now."
	git stash pop --quiet
    fi
}

equal=n
# sanity check:
if git-branch-exists $sum_branch;
then
    test_commit_parents
else
    git branch $sum_branch
fi
# todo?: if exists such branch/tag ->abort


if test "$equal" = y;
then
    {echo -n "no need to merge again -- the sum ";
	cecho magenta -n $sum_branch;
	echo " is up-to-date (as defined)." } >&2
    restore_stash
    exit 0
fi


####################################### Merge
first=$real_branches[1]

if [ $reset = "y" ]; then
    # Is this really necessary? only if
    #if [ $sum_branch = $(git branch) ]; then
	eval $cmd git checkout $first
    #fi
    eval $cmd git branch --force $sum_branch $first
    eval $cmd git checkout $sum_branch

else
    eval $cmd git checkout $sum_branch
    eval $cmd git merge $first;
fi
# git checkout -b $sum_branch $first

if test ${#real_branches} = 1;
then
    # if empty, we are done!
    test $debug = y && echo "the sum is trivial - 1 summand, no merging"
else
    others=($real_branches[2,-1])
# octopus is default (for >2 children) & refuses any conflict.

    {cecho green -n "re-merging sum ";cecho cyan $sum_branch} >&2
    set -x
    git merge -m "Sum: $sum_branch = $first + $others" \
	--rerere-autoupdate \
	-s octopus \
	-s recursive -X patience -X ignore-space-change $others

    restore_stash
fi
exit 0
# foreach next ($others)
# {
#     eval $cmd git merge -m "'Sum: $next into $sum_branch'" --rerere-autoupdate $next;
# }

