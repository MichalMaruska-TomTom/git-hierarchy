#! /usr/bin/zsh -feu

# re-make a "sum" branch:
source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)


# by default make a `clean' merge. This means
reset=y
dry=n

while getopts :rd OPT; do
    case $OPT in
	d)
	    dry=y;;
	r)
	    # reset:
	    reset=y
	    ;;
	+r)
	    reset=n
	    ;;
	*)
	    print "usage: ${0##*/} [+-r] [--] ARGS..."
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1

if [ $dry = "y" ]; then
    cmd="cecho red"
else
    cmd=""
fi

sum_br=$1


# how to
typeset -a branches

# get the list of summands:

branches=($(git for-each-ref "refs/sums/$sum_br/" --format "%(refname)"))
#(${(f)_tmp})
echo $branches

# try to resolve them ourselves:
typeset -a real_branches
real_branches=()

#foreach br ($branches) {real_branches+=$(dump_ref $br)}
foreach br ($branches) {real_branches+=$(dump_ref $br) }
echo $real_branches

git-branch-exists $sum_br || git branch $sum_br


# if exists such branch/tag ->abort
first=$real_branches[1]

others=($real_branches[2,-1])

if [ $reset = "y" ]; then
    eval $cmd git checkout $sum_br
    eval $cmd git reset --hard $first
else
    eval $cmd git checkout $sum_br
    eval $cmd git merge $first;
fi
# git checkout -b $sum_br $first

# octopus is default (for >2 children) & refuses any conflict.
#
git merge -m "Sum: $sum_br = $others + $first" \
    --rerere-autoupdate \
    -s octopus \
    -s recursive -X patience -X ignore-space-change $others


# foreach next ($others)
# {
#     eval $cmd git merge -m "'Sum: $next into $sum_br'" --rerere-autoupdate $next;
# }

