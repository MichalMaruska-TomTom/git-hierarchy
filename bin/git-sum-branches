#! /usr/bin/zsh -feu

usage()
{
    cat <<EOF
Remake a git sum/merge.

usage: ${0##*/} [-d] [+-r] [-h] [-s] [--] {sum}
-d  dry
-r  reset before starting merge. Default
+r  don't reset.
-v  verbose
-q  quiet (not-implemented)
-h  help
-s  stepwise: don't try to merge in 1 git-merge.
.... can contain upstream Git(1) options.
EOF
}


source /usr/share/git-hierarchy/functions.sh
GIT_DIR=$(git_dir)
# fixme:
cd $(git rev-parse --show-toplevel)


# by default make a `clean' merge. This means
reset=y
dry=n
cmd=""
debug=n
stepwise=0

while getopts :rdhvqs OPT; do
    case $OPT in
	d)
	    dry=y
	    cmd="cecho red"
	    ;;
	r)
	    # reset:
	    reset=y
	    ;;
	+r)
	    reset=n
	    ;;
	h)
	    usage
	    exit
	    ;;
	q)
	    # quiet silent
	    ;;
	s)
	    stepwise=1
	    ;;
	v)
	    debug=y
	    ;;
	*)
	    usage
	    exit 2
    esac
done
shift OPTIND-1
OPTIND=1

stash_if_non_clean "git-sum-branches saving"

if [ $# != 1 ]; then
    usage
    exit 1
fi

sum_name=$1

# git-sum
if ! is_sum $sum_name &>/dev/null ;
then
    echo "not a sum branch" >&2
    exit 1
fi

sum_branch=$(expand_ref $sum_name y)

#### Calculate the summands: for the check and for re-merging.
typeset -a summand_branches
summand_branches=(
    $(git for-each-ref "refs/sums/$sum_name/" --format "%(refname)") )
#(${(f)_tmp})
#test $debug = y &&     echo $summand_branches

# Those references are symbolic "ref: ref/head/NAME", but we want to
# use the NAMES in the commit message & interaction with the user.
# So, `resolve' them:
typeset -a real_branches
real_branches=()

foreach br ($summand_branches) {
    # local
    name=$(dump_ref_without_ref $br)
    name=${name#refs/heads/}
    real_branches+=$name
    }

test $debug = y && echo "Summands: $real_branches"



######################################## Test if up-to-date
test_commit_parents()
# expects the $summand_branches variable.
# "returns" the $equal variable
{
# take the branches' commit-ids
# and parent-ids of the sum's head.
# sort & compare
    local commit_ids_summands
    commit_ids_summands=()
    foreach br ($summand_branches) {
	commit_ids_summands+=$(commit_id $br)
    }

    test $debug = y && echo "Summands: $commit_ids_summands" >&2
    commit_ids_sum_parents=($(git show -s --format=format:"%P" $sum_branch))


    test $debug = y && echo "Parents: $commit_ids_sum_parents" >&2

# new criterion:
# the parents "include" all summands, and each parent is one of the summands.
# that is, each parent is fast-forward of summands and a summand itself.
# fixme!

# how to get common base for merge:
# git merge-base

    equal=y

# 1/ each parent is one of summands.
# But, if the merge is itself one of summands -> should be ok!

    set +u # here we risk the "var. lookup" fails, so treat it explicitly

    local sum_id
    sum_id=$(commit_id $sum_branch)
    if [[ ${commit_ids_summands[(r)$sum_id]} = $sum_id ]];then
	test $debug = y && cecho red "This merge is itself a summand." >&2
    else
# here the O(N^2) tests:
	foreach id ($commit_ids_sum_parents) {
	    if ! [[ ${commit_ids_summands[(r)$id]} = $id ]] ; then
		test $debug = y && cecho red "This parent is not in summands: $id" >&2
		equal=n
	    else
		test $debug = y && cecho green "found $id" >&2
	    fi
	}
    fi
    set -u # here again we don't (intend to) risk it.

# if test $equal = y
# then
# 2/ each summand is less than the sum. not -> N
    foreach id ($commit_ids_summands) {
	#if still a chance to win:
	if test $id = $sum_id; then
	    test $debug = y && echo ignoring ;  # for example S=a+b  but b>a.
	else
	    if test $equal = y;
	    then
		equal=n
            # SOME of the parent covers it:
		foreach parent ($commit_ids_sum_parents) {
		    if test $(git merge-base $parent $id) = $id
		    then
			test $debug = y && cecho green "$parent is greater than $id" >&2
			equal=y
		    else
	    # cecho green "found $id" >&2
			:
		    fi
		}
	    else
	    # no need to check further
		break;
	    fi
	fi
    }

}


equal=n
# sanity check:
test $debug = y && echo "sanity check" >&2
if git-branch-exists $sum_name;
then
    test_commit_parents
else
    git branch $sum_name
fi
# todo?: if exists such branch/tag ->abort


if test "$equal" = y;
then
    {echo -n "no need to merge again -- the sum ";
	cecho magenta -n $sum_name
	echo " is up-to-date (as defined)." } >&2
    unstash_if_stashed
    exit 0
fi


test $debug = y && echo "checkout & merge" >&2
####################################### Merge
# no way. `git-checkout' prefers branches (over tags)
# http://programmers.stackexchange.com/questions/230438/in-git-is-it-a-bad-idea-to-create-a-tag-with-the-same-name-as-a-deleted-branch
first=$real_branches[1]
first_branch=$(expand_ref $first)

if [ $reset = "y" ]; then
    # Is this really necessary? only if
    #if [ $sum_branch = $(git branch) ]; then
    eval $cmd git checkout --detach $first
    #fi
    eval $cmd git branch --force $sum_name HEAD
    eval $cmd git checkout $sum_name
else
    eval $cmd git checkout $sum_name
    # but here it is needed:
    eval $cmd git merge $first_branch
fi
# git checkout -b $sum_name $first

if test ${#real_branches} = 1;
then
    # if empty, we are done!
    test $debug = y && echo "the sum is trivial - 1 summand, no merging"
else
    others=($real_branches[2,-1])
# octopus is default (for >2 children) & refuses any conflict.

    {cecho green -n "re-merging sum ";cecho cyan $sum_name} >&2
    set -x
    if [ $stepwise = 0 ]; then
    eval $cmd git merge -m '"Sum: $sum_name = $first + $others"' \
	--rerere-autoupdate \
	-s octopus \
	-s recursive -X patience -X ignore-space-change $others
    else
	foreach next ($others)
	{
	    eval $cmd git merge -m "'Sum: $next into $sum_branch'" --rerere-autoupdate "'$next'";
	}
    fi
    unstash_if_stashed
fi
exit 0
