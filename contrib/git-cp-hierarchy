#!/bin/zsh -feu

source /usr/share/git-hierarchy/functions.sh
RM=/bin/rm

# Brings git-segments & sum over to another git repository.
# To be able to resume after a failure, existing segments/sums are not
# re-created!

# The `copy' is done by ... declaring the object anew, and populating
# the segments via patches.
# I.e. dumped by git-segment-patches and imported via  "git am".

# Works with `partial' subrepositories -- projections. The patches are
# limited to a subdirectory, or some subdirectories are ignored/excluded
# on the target side.
usage()
{
    cat <<EOF
usage: ${0##*/} [+-h] [--] {source-repo} {dest-repo} [ top ]

both {source-repo} {dest-repo} are git repositories.

TOP may indicate the top ref. Othwerwise all hierarchy refs are cloned.
EOF
}

typeset -A base_mapping
base_mapping=(refs/remotes/p4/master remotes/origin/master)


while getopts :h OPT; do
    case $OPT in
        h|+h)
            ;;
        *)
            usage >&2
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1

if [ $# -lt 2 ]
then
    usage
    exit 1
fi


# these Git repositories are involved:
readonly srcdir=$(realpath $1)
#~/wave3/p4cns/
readonly desttop=$(realpath $2)
#~/wave3/dgit/deauville-p4cns-main/

# todo: Framework.ThirdParty.freetype
# fixme: make sure the base exists!

cd $srcdir
GIT_DIR=$(git_dir)
cd $(git rev-parse --show-toplevel)


typeset -a refs
# the poset top:
if [ $# -ge 3 ]
then
    readonly TOP=$3 # "all-skia"
    readonly refs=($(git-walk-down $TOP))
else
    readonly refs=( $(git-tsort ) )
fi

am_parameter=()
segment_patches_args=()
destdir=$desttop

# input: $projection
# output: segment_patches_args am_parameter
prepare_am_parameter()
{
readonly navkit_path=Components/NavKit
readonly skia_path="Framework/ThirdParty/Skia/Implementation"

# This is the projection:
case $projection in
    top)
     # fixme: wrong var declaration?
        readonly destdir=$desttop
        readonly am_parameter="--exclude=$navkit_path/\*"
        readonly segment_patches_args=()
        ;;
    navkit)
        ## note:  -p3  so Components/NavKit/ is from --exlude=
        readonly destdir=$desttop/$navkit_path
        readonly am_parameter=("--exclude=$skia_path/\*" '-p3')
        readonly segment_patches_args=("$navkit_path/")
        ;;
    skia)
        # skia
        readonly destdir=$desttop/$navkit_path/$skia_path
        readonly segment_patches_args=("$navkit_path/$skia_path")
        readonly am_parameter=('-p7')
        ;;
    *)
        exit 2
        ;;
esac
}


function INFO()
{
    cecho yellow "$@"
}

function WARN()
{
    cecho red "$@"
}

WARN "will port $refs"

# skip over the base
foreach f ($refs) {
    name=${f##*/}
    cecho blue "$name"

    if git-sum $name >& /dev/null;
    then
        # note: this assumes that the summands are already created!

        INFO "recreate the sum $name"

        set -x
        summands=( $(git-sum $name) )
        sums=()
        foreach s ($summands) {sums+=(${s#refs/heads/}) }

        cd $destdir
        # is this check that it does not exist yet?
        if ! git-sum $name;
        then
            # echo "summands $summands"
            # set -x
            git-sum $name $sums
            # immediately, but that is already done?
            git-sum-branches $name
        fi

    elif git-segment $name >& /dev/null;
    then
        set -x
        # now inside $srcdir/ -- could be outside the cycle.
        PATCHES_DIR=$(realpath "tmp_patches")
        $RM -rf $PATCHES_DIR
        mkdir $PATCHES_DIR
        git-segment-patches -o $PATCHES_DIR $name $segment_patches_args

        # how to test existence?
        # test -n "$PATCHES_DIR/*"
        # if this wildcard does not match it will stay as is. so ls(1) will attempt /\* file.
        if ls $PATCHES_DIR/* > /dev/null ; then

            base=$(segment_base $name)
            base=${base#refs/heads/}
            INFO "create segment $name on its base: $base"

            cd $destdir
            if ! git-segment $name >& /dev/null ;
            then

                if [ -n "${base_mapping[$base]-}" ]
                then
                    base=$base_mapping[$base]
                    WARN "changing the base of $name to $base"
                fi

                git checkout $base
                # mmc: doesn't this do it?
                git-segment --checkout $name $base
                # are they ordered?

                # cherry-pick them:
                git am $am_parameter $PATCHES_DIR/*
                $RM -rf $PATCHES_DIR
            else
                cecho green "already exists"
            fi
        fi
        set +x
   else
       # fixme: make sure the base exists!
       WARN "skipping $f -- not a segment nor a sum."
    fi

    cd $srcdir
}


# foreach s  ( $(git-sum)) {git-delete $s}
# foreach s  ( $(git-segment -s)) {git-delete $s}


# patch -p1    <  .git/rebase-apply/patch
# git add --update
# git am --continue

# git-segment-patches -o tmp_patches skia Components/NavKit/
